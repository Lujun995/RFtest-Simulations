#Scenario 2: three sample outliers
#beta=0,0.5,1,1.5,2
#signal density=15%
#signal types = clustered vs. random
#four methods=RFtest, MiRKAT, OMiAT, aMiSPU
#three signal types=rare OTUs, abundant OTUs and phylogenetically clustered OTUs
#Including three sample outliers

#initialization
setwd("/hpc/home/lz197/RFomnibus/")#to modify according to computer
rm(list=ls())
source("randomForestTest_parallel_omnibus2.R")
source("getDescendants.R")
library(GUniFrac)
library(ranger)
library(ape)
library(vegan)
library(parallel)
library(ecodist)

n <- 50 #number of observations
iter <- 1000 #iterations, number of simulations

method=c("wRF","uwRF", "Omnibus.RF", "Omnibus.MiRKAT", "OMiAT", "MiHC", "aMiSPU")
beta0= 0
beta = c(0, 0.75, 1.5, 2.25, 3)
signal<-c("non-phylo","phylo")
Density=0.15
Density_s_1=c(0.05, 0.15) #Density in the scenario 1, to generate a y identical with the one in s1_b
outlier_n <- c(1,3)
pv.mat <- array(NA, 
                dim=c(iter, length(method), length(beta), length(signal), length(outlier_n)),
                dimnames = list(NULL, method, as.character(beta), signal, as.character(outlier_n))
                )#iter, method, beta, signal, outlier_n; indexed by h,i,j,k,l

load("/hpc/home/lz197/RFomnibus/adenoma_Li.RData")

#to generate the sample distribution and simulate a trait
set.seed(seed=23456)
data.obj$otu.tab->otu.tab
otu.tab<-t(otu.tab)
otu.tab[rowSums(otu.tab)>=20000, ]->data #sequencing depth >=20000
Rarefy(data)$otu.tab->data
data[,colSums(data)!=0]->data #439*2100 after rarefication
data.obj$tree->tree.rooted
#to locate the lineage (lineage A, C) comprising the following tips
lineageA<-getDescendants.tip(tree.rooted,node = 4190) #a abundant lineage
lineageA<-tree.rooted$tip.label[lineageA] #having ~15% OTUs in x, ~21.1% abundance of total
#length(lineageA)/length(tree.rooted$tip.label)
# droptips<-tree.rooted$tip.label[!(tree.rooted$tip.label %in% colnames(data))]
# setdiff(lineageA,droptips)->tempA
# sum(colSums(data[,tempA]))/sum(colSums(data))
lineageC<-getDescendants.tip(tree.rooted,node = 4300) #lineageC is a lineage under lineageA
lineageC<-tree.rooted$tip.label[lineageC] #having ~5% OTUs in x, ~10.9% abundance of total
# droptips<-tree.rooted$tip.label[!(tree.rooted$tip.label %in% colnames(data))]
# setdiff(lineageC,droptips)->tempC
# sum(colSums(data[,tempC]))/sum(colSums(data))
# length(lineageC)/length(tree.rooted$tip.label)

#Outliers by change the OTU order
#for(i in 1:3) data[i,]<-sample(data[i,])
#rownames(data)[1:3]<-c("outlier1","ourlier2","outlier3")
#GUniFrac(otu.tab = data,tree = tree.rooted, alpha = 0.5)$unifracs[,,"d_0.5"]->dis
#pheatmap::pheatmap(dis)

#Or else, directly use the outlier "CRC636xD707xD507"
# GUniFrac(otu.tab = data,tree = tree.rooted, alpha = 0.5)$unifracs[,,"d_0.5"]->dis
# pheatmap::pheatmap(dis)
# hist(apply(dis,MARGIN=1,median))
# rownames(dis)[apply(dis,MARGIN=1,median)>0.3]
# outlier="CRC636xD707xD507"
# outlier.pos<-which(rownames(data)==outlier)

set.seed(seed=23456) #resue the random seed from scenario 1 binary
#for different method, beta, signal, outlier_n, using the same x.index, x and phylogenetic tree
#for different iter, using different x and trees
#the outliers will be later created using the first 1-3 sample(s)
x.index<-matrix(NA, nrow=n, ncol=iter) #sample size, iter; indexed by g, h. Should be the same with s1_b
for(h in 1:iter) x.index[,h]<-sample(1:nrow(data),n)

#for different samples, iter, beta, signal, using different y
#for different methods, using the same y
#for different outlier_n, use the same y (correct signal)
y<-array(NA, 
         dim=c(n, iter, length(beta), length(signal), length(Density_s_1)),
         dimnames = list(NULL, NULL, as.character(beta),signal, as.character(Density_s_1))
)#sample size, iter, beta, signal, Density_s_1; indexed by g,h,j,k,l-1
#as for y, l means Density, while for pv.mat, l means outlier number


for(h in 1:iter){
  #generate x which are determined by the x.index
  #the x.index is determined by h
  x <- data[x.index[,h],]
  x <- x[,colSums(x)>=1]  #50*1506
  droptips<-tree.rooted$tip.label[!(tree.rooted$tip.label %in% colnames(x))]
  
  #Do NOT add outliers here as y should be generated by correct samples

  #Reused from s1_b. To generate y identical with s1_b
  #y varies according to different samples, iter, beta, signal
  for(k in 1:length(signal)){
	signal.tips<-vector(mode="list", length=length(Density_s_1))
	names(signal.tips)<-paste("Density_s_1=",c(0.05,0.15),sep="")
    if(signal[k]=="non-phylo"){
      OTU.list<-sample(colnames(x)) #randomize names of x for each iter
	  for(l in 1:length(Density_s_1)){
		#for different Density_s_1, use the same order of OTU.list
		#therefore, 1:round(ncol(x)*0.15) > 1:round(ncol(x)*0.05)
		signal.tips[[l]]<- OTU.list[1:round(ncol(x)*Density_s_1[l])]
	  }
    }else if(signal[k]=="phylo"){
	  for(l in 1:length(Density_s_1)){
		if(abs(Density_s_1[l]-0.05)<1e-5) 
			setdiff(lineageC,droptips)->signal.tips[[l]] else #the tips in the new tree in lineage C in each simulation
		if(abs(Density_s_1[l]-0.15)<1e-5)
			setdiff(lineageA,droptips)->signal.tips[[l]] else
		stop("Density_s_1 is not 0.05 or 0.15")
	  }
    }else stop("signal is not non-phylo or phylo")
	for(l in 1:length(Density_s_1)){
	  if(signal[k]=="non-phylo") #Zij/mean(Zj) to avoid a single or a few OTUs dominating the total effect.
		signal.strength<-rowSums(t(t(x[,signal.tips[[l]]]) / colMeans(x[,signal.tips[[l]]]))) else # matrix/vector element-wise
	  if(signal[k]=="phylo")
	    signal.strength<-rowSums(x[,signal.tips[[l]]])
	  q=beta0+matrix(beta, ncol=1) %*% matrix(scale(signal.strength), nrow=1)#for each beta and sample, signal tips are the same
      rownames(q)<-as.character(beta);colnames(q)<-names(signal.strength)
      p=exp(q)/(1+exp(q)) #inverse logit function
      y[ ,h, ,k,l] <- apply(X=p, MARGIN=1, FUN=rbinom, n=n, size=1) #to simulate a trait
	  #NOTE on rbinom: rbinom(n, size, prob), if n < length(prob), it will generate the first nth binomial random variable 
	  #according to p; if n > length(prob), it will recycle prob; if n = length(prob), it will give the binomial sample according
	  #to the probability given by prob. Therefore, as the row of p is the probability of one sample under a specific beta,
	  #this apply(X=p, MARGIN=1, FUN=rbinom, n=n, size=1) should generate the desired binomial random sample (with different
      #probability).
	  #temp<-sapply(1:1e4, function(i) rbinom(n=5, size=1, prob=c(0.1,0.2,0.4,0.6,0.8)))
	  #apply(temp,MARGIN=1,sum)/1e4
	}
  }
}

save.image(file="/hpc/home/lz197/RFomnibus/s2_b_run5.RData")

#on computer cluster
cores = 10 #to modify according to computer

for(h in 1:iter){
  set.seed(seed = h) #a somewhat dirty method
  if(h %% round(iter/100) == 0) cat(".")
  #generate x which are determined by the x.index
  #the x.index is determined by h
  x <- data[x.index[,h],]
  x <- x[,colSums(x)>=1]  #50*1506

  #add outliers
  x.list<-vector(mode = "list", length=length(outlier_n))
  for(l in 1:length(outlier_n)){
    if(l ==1) {
      x.list[[l]] <- x
    } else x.list[[l]] <- x.list[[l-1]]  #inherent from the previous x, to make them comparable
    
    if(l ==1) {
      st <- 1
      en <- outlier_n[l]
    } else {
      st <- outlier_n[l-1]+1
      en <- outlier_n[l]
    }
    
    for(temp in st:en) 
      x.list[[l]][temp, ] <- sample(x.list[[l]][temp, ]) #determined by the random seed above; thus, determined by h
    rownames(x.list[[l]])[st:en] <- paste("outlier", st:en, sep="")
  }
  
  #re-exclude all-zero OTUs and adapt phylogenetic tree
  tree.list <- vector(mode = "list", length=length(outlier_n))
  for(l in 1:length(outlier_n)){
    x.list[[l]] <- x.list[[l]][,colSums(x.list[[l]])>=1]
    droptips<-tree.rooted$tip.label[!(tree.rooted$tip.label %in% colnames(x.list[[l]]))] #not used in the following steps
    tree.list[[l]] <- drop.tip(phy = tree.rooted, tip = droptips) #a real tree
    if(sum(!(colnames(x.list[[l]]) %in% tree.list[[l]]$tip.label))==0) 
      x.list[[l]]<-x.list[[l]][,tree.list[[l]]$tip.label] else stop("don't match") #order x according to the tree
  }
  
  # #For MiRKAT
  # Ks<-vector(mode = "list", length=length(outlier_n))
  # for(l in 1:length(outlier_n)){
    # unifracs = GUniFrac(x.list[[l]], tree=tree.list[[l]], alpha = c(1))$unifracs
    # Ds = list(w = unifracs[,,"d_1"], uw = unifracs[,,"d_UW"],
              # BC= as.matrix(vegdist(x.list[[l]], method="bray")))
    # Ks[[l]] = lapply(Ds, FUN = function(d) MiRKAT::D2K(d))
  # }
  
  for(k in 1:length(signal)){
		for(j in 1:length(beta)){
			for(l in 1:length(outlier_n)) {
				#method[i]=c("wRF","uwRF", "Omnibus.RF", "Omnibus.MiRKAT", "OMiAT", "MiHC", "aMiSPU")
				#obtain y=y[ ,h,j,k,"0.15"]
				#RF omnibus test
				pv1 <- randomForestTest_parallel_omnibus2(comm = x.list[[l]] , meta.data = data.frame(y=factor(y[ ,h,j,k,"0.15"])), tree=tree.list[[l]], 
					   response.var="y", perm.no = 999, n.cores=cores, test.type = "Training",method = "o")
				pv1$p.value.perm[c("weighted", "unweighted","Omnibus")]->pv.mat[h,c("wRF", "uwRF","Omnibus.RF"),j,k,l]
				# #MiRKAT
				# pv2 <- MiRKAT::MiRKAT(y[ ,h,j,k,"0.15"], Ks = Ks[[l]], out_type="D",nperm=999)
				# pv2$omnibus_p -> pv.mat[h,c("Omnibus.MiRKAT"),j,k,l]
				# #OMiAT
				# pv3 <- OMiAT::OMiAT(Y=y[ ,h,j,k,"0.15"], otu.tab=x.list[[l]], tree=tree.list[[l]], model="binomial",n.perm=999)
				# pv3$OMiAT.pvalue -> pv.mat[h,c("OMiAT"),j,k,l]
				# #aMiSPU
				# pv4 <- MiSPU::MiSPU(y = y[ ,h,j,k,"0.15"], X= as.matrix(x.list[[l]]), tree=tree.list[[l]], model="binomial", n.perm = 999)
				# pv4$aMiSPU$pvalue -> pv.mat[h,c("aMiSPU"),j,k,l]
				# # #MiHC
				# # pv5 <- MiHC::MiHC(y=y[ ,h,j,k,"0.15"], otu.tab=x.list[[l]], tree = tree.list[[l]], model="binomial", n.perm=999)
				# # pv5$ada.pvs["MiHC"] -> pv.mat[h,c("MiHC"),j,k,l]
			}
		}
  }
  if(h %% round(iter/100) == 0) save.image(file="/hpc/home/lz197/RFomnibus/s2_b_run5.RData")
}
save.image(file="/hpc/home/lz197/RFomnibus/s2_b_run5.RData")

