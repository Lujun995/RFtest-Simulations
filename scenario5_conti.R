#Source code for the scenario 5 (clear): three sample outliers
#beta=0, 0.25, 0.5, 0.75, 1
#signal density=15%
#signal types = clustered vs. random
#four methods=RFtest, MiRKAT, OMiAT, aMiSPU
#Including three sample outliers

#initialization
setwd("/hpc/home/lz197/RFomnibus/")#to modify according to computer
rm(list=ls())
source("randomForestTest.R")
source("getDescendants.R")
library(GUniFrac)
library(ranger)
library(ape)
library(vegan)
library(parallel)
library(ecodist)

n <- 50 #number of observations
iter <- 1000 #iterations, number of simulations

method=c("wRF","uwRF", "Omnibus.RF", "Omnibus.MiRKAT", "OMiAT", "aMiSPU")
beta0= 10
beta = c(0, 0.25, 0.5, 0.75, 1)
signal<-c("non-phylo","phylo")
Density=0.15
Density_s_1=c(0.05, 0.15) #Density in the scenario 1, to generate a y identical with the one in s1_b
outlier_n <- c(1,3)
pv.mat <- array(NA, 
                dim=c(iter, length(method), length(beta), length(signal), length(outlier_n)),
                dimnames = list(NULL, method, as.character(beta), signal, as.character(outlier_n))
                )#iter, method, beta, signal, outlier_n; indexed by h,i,j,k,l

load("/hpc/home/lz197/RFomnibus/adenoma_Li.RData")

#to generate the sample distribution and simulate a trait
set.seed(seed=23456)
data.obj$otu.tab->otu.tab
otu.tab<-t(otu.tab)
otu.tab[rowSums(otu.tab)>=20000, ]->data #sequencing depth >=20000
Rarefy(data)$otu.tab->data
data[,colSums(data)!=0]->data #439*2100 after rarefication
data.obj$tree->tree.rooted
#to locate the lineage (lineage A, C) comprising the following tips
lineageA<-getDescendants.tip(tree.rooted,node = 4190) #a abundant lineage
lineageA<-tree.rooted$tip.label[lineageA] #having ~15% OTUs in x, ~21.1% abundance of total
#length(lineageA)/length(tree.rooted$tip.label)
# droptips<-tree.rooted$tip.label[!(tree.rooted$tip.label %in% colnames(data))]
# setdiff(lineageA,droptips)->tempA
# sum(colSums(data[,tempA]))/sum(colSums(data))
lineageC<-getDescendants.tip(tree.rooted,node = 4300) #lineageC is a lineage under lineageA
lineageC<-tree.rooted$tip.label[lineageC] #having ~5% OTUs in x, ~10.9% abundance of total
# droptips<-tree.rooted$tip.label[!(tree.rooted$tip.label %in% colnames(data))]
# setdiff(lineageC,droptips)->tempC
# sum(colSums(data[,tempC]))/sum(colSums(data))
# length(lineageC)/length(tree.rooted$tip.label)

#Outliers by change the OTU order
#for(i in 1:3) data[i,]<-sample(data[i,])
#rownames(data)[1:3]<-c("outlier1","ourlier2","outlier3")
#GUniFrac(otu.tab = data,tree = tree.rooted, alpha = 0.5)$unifracs[,,"d_0.5"]->dis
#pheatmap::pheatmap(dis)

#Or else, directly use the outlier "CRC636xD707xD507"
# GUniFrac(otu.tab = data,tree = tree.rooted, alpha = 0.5)$unifracs[,,"d_0.5"]->dis
# pheatmap::pheatmap(dis)
# hist(apply(dis,MARGIN=1,median))
# rownames(dis)[apply(dis,MARGIN=1,median)>0.3]
# outlier="CRC636xD707xD507"
# outlier.pos<-which(rownames(data)==outlier)

set.seed(seed=1123456) #resue the random seed from scenario 1 continuous
#for different method, beta, signal, outlier_n, using the same x.index, x and phylogenetic tree
#for different iter, using different x and trees
#the outliers will be later created using the first 1-3 sample(s)
x.index<-matrix(NA, nrow=n, ncol=iter) #sample size, iter; indexed by g, h. Should be the same with s1_b
for(h in 1:iter) x.index[,h]<-sample(1:nrow(data),n)

#for different samples, iter, beta, signal, using different y
#for different methods, using the same y
#for different outlier_n, use the same y (correct signal)
y<-array(NA, 
         dim=c(n, iter, length(beta), length(signal), length(Density_s_1)),
         dimnames = list(NULL, NULL, as.character(beta),signal, as.character(Density_s_1))
)#sample size, iter, beta, signal, Density_s_1; indexed by g,h,j,k,l-1
#as for y, l means Density, while for pv.mat, l means outlier number


for(h in 1:iter){
  #generate x which are determined by the x.index
  #the x.index is determined by h
  x <- data[x.index[,h],]
  x <- x[,colSums(x)>=1]  #50*1506
  droptips<-tree.rooted$tip.label[!(tree.rooted$tip.label %in% colnames(x))]
  
  #Do NOT add outliers here as y should be generated by correct samples

  #Reused from s1_c. To generate y identical with s1_c
  #y varies according to different samples, iter, beta, signal
  for(k in 1:length(signal)){
	signal.tips<-vector(mode="list", length=length(Density_s_1))
	names(signal.tips)<-paste("Density_s_1=",Density_s_1,sep="")
    if(signal[k]=="non-phylo"){
      OTU.list<-sample(colnames(x)) #randomize names of x for each iter
	  for(l in 1:length(Density_s_1)){
		#for different Density_s_1, use the same order of OTU.list
		#therefore, 1:round(ncol(x)*0.15) > 1:round(ncol(x)*0.05)
		signal.tips[[l]]<- OTU.list[1:round(ncol(x)*Density_s_1[l])]
	  }
    }else if(signal[k]=="phylo"){
	  for(l in 1:length(Density_s_1)){
		if(abs(Density_s_1[l]-0.05)<1e-5) 
			setdiff(lineageC,droptips)->signal.tips[[l]] else #the tips in the new tree in lineage C in each simulation
		if(abs(Density_s_1[l]-0.15)<1e-5)
			setdiff(lineageA,droptips)->signal.tips[[l]] else
		stop("Density_s_1 is not 0.05 or 0.15")
	  }
    }else stop("signal is not non-phylo or phylo")
	for(l in 1:length(Density_s_1)){
	  if(signal[k]=="non-phylo") #Zij/mean(Zj) to avoid a single or a few OTUs dominating the total effect.
		signal.strength<-rowSums(t(t(x[,signal.tips[[l]]]) / colMeans(x[,signal.tips[[l]]]))) else # matrix/vector element-wise
	  if(signal[k]=="phylo")
	    signal.strength<-rowSums(x[,signal.tips[[l]]])
	  q=beta0+
		matrix(beta, ncol=1) %*% matrix(scale(signal.strength), nrow=1)#for each beta and sample, signal tips are the same
      rownames(q)<-as.character(beta);colnames(q)<-names(signal.strength)
	  temp <- rnorm(n) # for different Density, use different error term
	  y[ ,h, ,k,l] <- apply(X=q, MARGIN = 1, "+" ,temp) #for each beta, the added noise are the same
	}
  }
}

save.image(file="/hpc/home/lz197/RFomnibus/s5_c.RData")

#on computer cluster
cores = 10 #to modify according to computer

for(h in 1:iter){
  set.seed(seed = h+1000) #a somewhat dirty method
  if(h %% round(iter/100) == 0) cat(".")
  #generate x which are determined by the x.index
  #the x.index is determined by h
  x <- data[x.index[,h],]
  x <- x[,colSums(x)>=1]  #50*1506

  #add outliers
  x.list<-vector(mode = "list", length=length(outlier_n))
  for(l in 1:length(outlier_n)){
    if(l ==1) {
      x.list[[l]] <- x
    } else x.list[[l]] <- x.list[[l-1]]  #inherent from the previous x, to make them comparable
    
    if(l ==1) {
      st <- 1
      en <- outlier_n[l]
    } else {
      st <- outlier_n[l-1]+1
      en <- outlier_n[l]
    }
    
    for(temp in st:en) 
      x.list[[l]][temp, ] <- sample(x.list[[l]][temp, ]) #determined by the random seed above; thus, determined by h
    rownames(x.list[[l]])[st:en] <- paste("outlier", st:en, sep="")
  }
  
  #re-exclude all-zero OTUs and adapt phylogenetic tree
  tree.list <- vector(mode = "list", length=length(outlier_n))
  for(l in 1:length(outlier_n)){
    x.list[[l]] <- x.list[[l]][,colSums(x.list[[l]])>=1]
    droptips<-tree.rooted$tip.label[!(tree.rooted$tip.label %in% colnames(x.list[[l]]))] #not used in the following steps
    tree.list[[l]] <- drop.tip(phy = tree.rooted, tip = droptips) #a real tree
    if(sum(!(colnames(x.list[[l]]) %in% tree.list[[l]]$tip.label))==0) 
      x.list[[l]]<-x.list[[l]][,tree.list[[l]]$tip.label] else stop("don't match") #order x according to the tree
  }
  
  #For MiRKAT
  Ks<-vector(mode = "list", length=length(outlier_n))
  for(l in 1:length(outlier_n)){
    unifracs = GUniFrac(x.list[[l]], tree=tree.list[[l]], alpha = c(1))$unifracs
    Ds = list(w = unifracs[,,"d_1"], uw = unifracs[,,"d_UW"],
              BC= as.matrix(vegdist(x.list[[l]], method="bray")))
    Ks[[l]] = lapply(Ds, FUN = function(d) MiRKAT::D2K(d))
  }
  
  for(k in 1:length(signal)){
		for(j in 1:length(beta)){
			for(l in 1:length(outlier_n)) {
				#method[i]=c("wRF","uwRF", "Omnibus.RF", "Omnibus.MiRKAT", "OMiAT", "MiHC", "aMiSPU")
				#obtain y=y[ ,h,j,k,"0.15"]
				#RF omnibus test
				pv1 <- randomForestTest(comm = x.list[[l]] , meta.data = data.frame(y=y[ ,h,j,k,"0.15"]), tree=tree.list[[l]], 
					   response.var="y", perm.no = 999, n.cores=cores, test.type = "OOB",method = "w", prediction.type = 'Regression',presence.in=1)
				pv1$p.value.perm->pv.mat[h,c("wRF"),j,k,l]
				#MiRKAT
				pv2 <- MiRKAT::MiRKAT(y[ ,h,j,k,"0.15"], Ks = Ks[[l]], out_type="C",nperm=999)
				pv2$omnibus_p -> pv.mat[h,c("Omnibus.MiRKAT"),j,k,l]
				#OMiAT
				pv3 <- OMiAT::OMiAT(Y=y[ ,h,j,k,"0.15"], otu.tab=x.list[[l]], tree=tree.list[[l]], model="continous",n.perm=999)
				pv3$OMiAT.pvalue -> pv.mat[h,c("OMiAT"),j,k,l]
				#aMiSPU
				pv4 <- MiSPU::MiSPU(y = y[ ,h,j,k,"0.15"], X= as.matrix(x.list[[l]]), tree=tree.list[[l]], model="gaussian", n.perm = 999)
				pv4$aMiSPU$pvalue -> pv.mat[h,c("aMiSPU"),j,k,l]
			}
		}
  }
  if(h %% round(iter/100) == 0) save.image(file="/hpc/home/lz197/RFomnibus/s5_c.RData")
}
save.image(file="/hpc/home/lz197/RFomnibus/s5_c.RData")

